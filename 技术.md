1. agent 框架：

   1. langchain （langgraph）:生态完整，支持图状工作流，适合复杂多步骤任务
   2. crewAI: multi agent， 每个agent 明确分工，多专家协同类型工作
   3. AutoGen: 微软出品，对话式多agent系统很强。
   4. OpenAI Agents SDK: 轻量，支持100多种不同的大模型，内置追踪和安全防护。适合实际生产环境项目
   5. semantic Kernel: 企业级应用，与微软生态深度集成，在安全性和合规性方面做得比较到位
   6. Haystack：问答系统或者知识库检索。
2. langgraph.graph 中的StateGraph ：

   1. [LangGraph](https://www.langchain.com/langgraph)
   2. 作用辅助构建工作流
   3. 设置节点+边/条件边--> 完整的状态转换控制图
   4. agent node
   5. tool node
   6. edge 三类start normal conditional
   7. stream--需要构建好图以及条件逻辑后，通过compile
3. 包含decision 部分
4. 包含实时反馈部分
5. Trading agent 的项目结构：

   1. agents ：agent node ， 每个node 用的什么大模型quick +用户选择，并绑定工具tool node。全部都是一样的，具体的工具和模型不一样
   2. dataflow：具体的tool node 的方法，包含怎么调用api的工具
   3. graph：
      1. trading graph, 核心类，包含整个工作流的形状（初始化各个node, 初始化控制，初始化reflector, 初始化 最终的信号处理类）
      2. setup 根据用户的参数+trading graph 的形状，添加节点与边到lang graph stategraph 的工作流中去，也就是能按照用户指定构建工作流
      3. conditional_logic： 判断条件类。各个函数接收当前的状态，返回是否要跳转的信号，以及跳转到哪的信号
      4. propagation：初始化的时候，整体消息结构输入的控制。--结构化通信
      5. reflection: 类。将loss 插入到各个agent 的memory 中
      6. signal processing: 从最后的消息内容中获取decision 只是一个单一的 hold sold buy
6. 实现1， 能闭环更新现状

   1. 需要一个/多个函数，控制调用:分析（traing graph 设置到当前时间）->decision（signal processing）->trade(新写一个函数，根据decision 去操作)-->return loss （调用tool node中跟价格相关的api 获取第二次操作时的价格，计算loss）--> update memory(relection 类)-->循环
   2. 怎么返回价格： 修改 agents node 中的prompt 即可，现在的提示是根据现金流（这个结构化通信里面有，但是没有让用户提供，这里也需要找到，改，看到过，忘记在哪了，应该是跟prompt 关联的里面）各种当前的状况+只分析股票的prompt, 将prompt 修改让返回，（hold）(sell : volumn)(buy,volumn)
   3. 怎么分析整个市场，这个地方的变动最大了。
      1. 1. 消息结构，要变成分析什么市场。
      2. 2. 这里面的调用tool node 可能需要修改，还没有仔细查看。或许变成循环调用？但是更耗时，最好是一次性运行提供。这里直观感觉很麻烦
      3. 3.prompt 这里提示肯定要改，参数的placehold也要对应的修改，这个部分不难。
